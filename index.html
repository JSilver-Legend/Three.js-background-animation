<!DOCTYPE html>

<head>
	<link href="main.css" rel="stylesheet" type='text/css'>
	<script src="assets/libraries/jquery.min.js"></script> <!-- jquery JS (https://jquery.com) -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.3/TweenMax.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js" integrity="sha512-f8mwTB+Bs8a5c46DEm7HQLcJuHMBaH/UFlcgyetMqqkvTcYg4g5VXsYR71b3qC82lZytjNYvBj2pf0VekA9/FQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
	<div class="canvas" id="canvas"></div>
	<div class="overlay">
		<section>
			<div class="title-first">
				<div> Here is Step 1</div>
				<div>content - 1</div>
			</div>
		</section>
		<section>
			<div class="title-second">
				<div>Here is Step 2</div>
				<div>content - 2</div>
			</div>
		</section>
	</div>
	<script type="module">

		import * as THREE from './assets/libraries/three.module.js';
		import { OrbitControls } from './assets/libraries/OrbitControls.js';
		import { EffectComposer } from './assets/libraries/EffectComposer.js';
		import { RenderPass } from './assets/libraries/RenderPass.js';
		import { UnrealBloomPass } from './assets/libraries/UnrealBloomPass.js';
		import { GLTFLoader } from './assets/libraries/GLTFLoader.js';

		const scene = new THREE.Scene();
		scene.background = new THREE.Color('#000000');

		let renderer, camera, clock, controls, composer;

		let mesh1;
		let mesh2;

		const params = {
			exposure: 1,
			bloomStrength: 1,
			bloomThreshold: 0,
			bloomRadius: 0
		};

		window.addEventListener('scroll',function(e) {
			console.log(window.scrollY);
			if( window.scrollY >= 500 && window.scrollY < 1050 ) {
				gsap.to(mesh2.position, {
				duration: 1,
				x: 100 + 150 * (window.scrollY - 500 ) / 500,
				delay: 0,
				ease: 'back.out(0.8)',
				});
				gsap.to(mesh2.rotation, {
					duration: 1,
					y: 2 * Math.PI * ( (window.scrollY - 500 )/ 500 ),
					delay: 0,
					ease: 'back.out(0.8)'
				});
				gsap.to(mesh2.scale, {
					duration: 1,
					x: 7.5 + 5 * (window.scrollY - 500 ) / 500,
					y: 7.5 + 5 * (window.scrollY - 500 ) / 500,
					z: 7.5 + 5 * (window.scrollY - 500 ) / 500,
					delay: 0,
					ease: 'back.out(0.8)'
				});
			} else if( window.scrollY >= 1050 ) {
				gsap.to(mesh1.position, {
				duration: 1,
				x: 350 - 250 * (window.scrollY - 1050 ) / 500,
				delay: 0,
				ease: 'back.out(0.8)',
				});
				gsap.to(mesh1.rotation, {
					duration: 1,
					y: 3 * (window.scrollY - 1050) / 500,
					delay: 0,
					ease: 'back.out(0.8)'
				});
				gsap.to(mesh1.scale, {
					duration: 1,
					x: 2 - (window.scrollY - 1050 ) / 500,
					y: 2 - (window.scrollY - 1050 ) / 500,
					z: 2 - (window.scrollY - 1050 ) / 500,
					delay: 0,
					ease: 'back.out(0.8)'
				});
			}
		});

		init();

		function init() {
			const container = document.getElementById('canvas');
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.toneMapping = THREE.ReinhardToneMapping;
			container.appendChild(renderer.domElement);

			clock = new THREE.Clock();

			camera = new THREE.PerspectiveCamera(12, window.innerWidth / window.innerHeight, 1, 3000);

			scene.add(camera);
			
			camera.position.set(0, 1000, 0);

			const loader = new GLTFLoader();

			loader.load( './assets/model/earth2.glb', function ( gltf ) {
				let material = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.01 })
				mesh1 = new THREE.Points(gltf.scene.children[0].children[1].geometry, material)
				console.log(mesh1)
				scene.add(mesh1)
				mesh1.rotation.set(-Math.PI/2, 0, 0);
				mesh1.position.set(350,0,0);
				mesh1.scale.set(2,2,2);
				console.log(mesh1.rotation);
			} );

			loader.load( './assets/model/Marina_C.glb', function ( gltf ) {
				console.log(gltf);
				let material = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.01 })
				mesh2 = new THREE.Points(gltf.scene.children[0].children[0].geometry, material)
				mesh2.rotation.set(-Math.PI/2, 0, 0);
				scene.add(mesh2)
				mesh2.position.set(100,0,90)
				mesh2.scale.set(7.5,7.5,7.5);
			} );

			scene.add(new THREE.AmbientLight(0xffffff, 10));
			const pointLight = new THREE.PointLight(0xffffff, 10);
			scene.add(pointLight);
			pointLight.position.set(0, 0, 0);

			controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.enableRotate = false;
			controls.target.set(0, 0, 0);
			controls.update();

			const renderScene = new RenderPass(scene, camera);
			const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
			bloomPass.threshold = params.bloomThreshold;
			bloomPass.strength = params.bloomStrength;
			bloomPass.radius = params.bloomRadius;

			composer = new EffectComposer(renderer);
			composer.addPass(renderScene);
			composer.addPass(bloomPass);

			animate();
		}

		function animate() {
			requestAnimationFrame(animate);
			const delta = clock.getDelta();
			controls.update();
			composer.render();
		}

	</script>
</body>